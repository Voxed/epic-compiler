/* This Bison file was machine-generated by BNFC */
%{
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include "ParserError.H"
#include "Absyn.H"

#define YYMAXDEPTH 10000000

typedef struct yy_buffer_state *YY_BUFFER_STATE;
int yyparse(void);
int yylex(void);
YY_BUFFER_STATE parseryy_scan_string(const char *str);
void parseryy_delete_buffer(YY_BUFFER_STATE buf);
int parseryy_mylinenumber;
void parserinitialize_lexer(FILE * inp);
int parseryywrap(void)
{
  return 1;
}
void parseryyerror(const char *str)
{
  throw parser::parse_error(parseryy_mylinenumber,str);
}

namespace parser
{

static Program* YY_RESULT_Program_ = 0;

Program* pProgram(FILE *inp)
{
  parseryy_mylinenumber = 1;
  parserinitialize_lexer(inp);
  if (yyparse())
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_Program_;
  }
}
Program* pProgram(const char *str)
{
  YY_BUFFER_STATE buf;
  int result;
  parseryy_mylinenumber = 1;
  parserinitialize_lexer(0);
  buf = parseryy_scan_string(str);
  result = yyparse();
  parseryy_delete_buffer(buf);
  if (result)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return YY_RESULT_Program_;
  }
}


}
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  parser::Program* program_;
  parser::Def* def_;
  parser::ListDef* listdef_;
  parser::Arg* arg_;
  parser::ListArg* listarg_;
  parser::ListStm* liststm_;
  parser::Stm* stm_;
  parser::Dec* dec_;
  parser::ListDec* listdec_;
  parser::Type* type_;
  parser::ListType* listtype_;
  parser::Exp* exp_;
  parser::ListExp* listexp_;
  parser::AddOp* addop_;
  parser::MulOp* mulop_;
  parser::RelOp* relop_;
  parser::Length* length_;
  parser::ListLength* listlength_;
  parser::Struct* struct_;
  parser::Field* field_;
  parser::ListField* listfield_;
  parser::Member* member_;
  parser::ListMember* listmember_;
}
%define api.prefix {parseryy}
%token _ERROR_
%token _SYMB_10    //   !
%token _SYMB_22    //   !=
%token _SYMB_16    //   %
%token _SYMB_11    //   &&
%token _SYMB_0    //   (
%token _SYMB_1    //   )
%token _SYMB_28    //   )null
%token _SYMB_14    //   *
%token _SYMB_13    //   +
%token _SYMB_7    //   ++
%token _SYMB_4    //   ,
%token _SYMB_9    //   -
%token _SYMB_8    //   --
%token _SYMB_29    //   ->
%token _SYMB_27    //   .
%token _SYMB_15    //   /
%token _SYMB_23    //   :
%token _SYMB_5    //   ;
%token _SYMB_17    //   <
%token _SYMB_18    //   <=
%token _SYMB_6    //   =
%token _SYMB_21    //   ==
%token _SYMB_19    //   >
%token _SYMB_20    //   >=
%token _SYMB_25    //   [
%token _SYMB_24    //   []
%token _SYMB_26    //   ]
%token _SYMB_30    //   boolean
%token _SYMB_31    //   class
%token _SYMB_32    //   double
%token _SYMB_33    //   else
%token _SYMB_34    //   extends
%token _SYMB_35    //   false
%token _SYMB_36    //   for
%token _SYMB_37    //   if
%token _SYMB_38    //   int
%token _SYMB_39    //   new
%token _SYMB_40    //   return
%token _SYMB_41    //   struct
%token _SYMB_42    //   true
%token _SYMB_43    //   typedef
%token _SYMB_44    //   void
%token _SYMB_45    //   while
%token _SYMB_2    //   {
%token _SYMB_12    //   ||
%token _SYMB_3    //   }

%type <program_> Program
%type <def_> Def
%type <listdef_> ListDef
%type <arg_> Arg
%type <listarg_> ListArg
%type <liststm_> ListStm
%type <stm_> Stm
%type <dec_> Dec
%type <listdec_> ListDec
%type <type_> Type
%type <listtype_> ListType
%type <exp_> Exp7
%type <exp_> Exp5
%type <exp_> Exp4
%type <exp_> Exp3
%type <exp_> Exp2
%type <exp_> Exp1
%type <exp_> Exp
%type <exp_> Exp6
%type <listexp_> ListExp
%type <addop_> AddOp
%type <mulop_> MulOp
%type <relop_> RelOp
%type <length_> Length
%type <listlength_> ListLength
%type <struct_> Struct
%type <field_> Field
%type <listfield_> ListField
%type <member_> Member
%type <listmember_> ListMember

%start Program
%token<_string> _STRING_
%token<_char>   _CHAR_
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%%
Program : ListDef {  std::reverse($1->begin(),$1->end()) ;$$ = new parser::PDefs($1); parser::YY_RESULT_Program_= $$; }
;
Def : Type _IDENT_ _SYMB_0 ListArg _SYMB_1 _SYMB_2 ListStm _SYMB_3 {  std::reverse($4->begin(),$4->end()) ;$$ = new parser::DFun($1, $2, $4, $7);  }
  | _SYMB_43 _SYMB_41 _IDENT_ _SYMB_14 _IDENT_ _SYMB_5 {  $$ = new parser::DPointer($3, $5);  }
  | Struct _SYMB_5 {  $$ = new parser::DStruct($1);  }
  | _SYMB_43 Struct _SYMB_14 _IDENT_ _SYMB_5 {  $$ = new parser::DInlinePointer($2, $4);  }
  | _SYMB_31 _IDENT_ _SYMB_2 ListMember _SYMB_3 {  $$ = new parser::DClass($2, $4);  }
  | _SYMB_31 _IDENT_ _SYMB_34 _IDENT_ _SYMB_2 ListMember _SYMB_3 {  $$ = new parser::DSubclass($2, $4, $6);  }
;
ListDef : Def {  $$ = new parser::ListDef() ; $$->push_back($1);  }
  | Def ListDef {  $2->push_back($1) ; $$ = $2 ;  }
;
Arg : Type _IDENT_ {  $$ = new parser::ADecl($1, $2);  }
;
ListArg : /* empty */ {  $$ = new parser::ListArg();  }
  | Arg {  $$ = new parser::ListArg() ; $$->push_back($1);  }
  | Arg _SYMB_4 ListArg {  $3->push_back($1) ; $$ = $3 ;  }
;
ListStm : /* empty */ {  $$ = new parser::ListStm();  }
  | ListStm Stm {  $1->push_back($2) ; $$ = $1 ;  }
;
Stm : _SYMB_5 {  $$ = new parser::SEmpty();  }
  | _SYMB_2 ListStm _SYMB_3 {  $$ = new parser::SBlock($2);  }
  | Type ListDec _SYMB_5 {  std::reverse($2->begin(),$2->end()) ;$$ = new parser::SDecl($1, $2);  }
  | Exp _SYMB_6 Exp _SYMB_5 {  $$ = new parser::SAss($1, $3);  }
  | Exp _SYMB_7 _SYMB_5 {  $$ = new parser::SIncr($1);  }
  | Exp _SYMB_8 _SYMB_5 {  $$ = new parser::SDecr($1);  }
  | _SYMB_40 Exp _SYMB_5 {  $$ = new parser::SRet($2);  }
  | _SYMB_40 _SYMB_5 {  $$ = new parser::SVRet();  }
  | _SYMB_37 _SYMB_0 Exp _SYMB_1 Stm {  $$ = new parser::SCond($3, $5);  }
  | _SYMB_37 _SYMB_0 Exp _SYMB_1 Stm _SYMB_33 Stm {  $$ = new parser::SCondElse($3, $5, $7);  }
  | _SYMB_45 _SYMB_0 Exp _SYMB_1 Stm {  $$ = new parser::SWhile($3, $5);  }
  | Exp _SYMB_5 {  $$ = new parser::SExp($1);  }
  | _SYMB_36 _SYMB_0 Type _IDENT_ _SYMB_23 Exp _SYMB_1 Stm {  $$ = new parser::SForEach($3, $4, $6, $8);  }
;
Dec : _IDENT_ {  $$ = new parser::DecNoInit($1);  }
  | _IDENT_ _SYMB_6 Exp {  $$ = new parser::DecInit($1, $3);  }
;
ListDec : Dec {  $$ = new parser::ListDec() ; $$->push_back($1);  }
  | Dec _SYMB_4 ListDec {  $3->push_back($1) ; $$ = $3 ;  }
;
Type : _SYMB_38 {  $$ = new parser::TInt();  }
  | _SYMB_32 {  $$ = new parser::TDouble();  }
  | _SYMB_30 {  $$ = new parser::TBool();  }
  | _SYMB_44 {  $$ = new parser::TVoid();  }
  | Type _SYMB_24 {  $$ = new parser::TArray($1);  }
  | _IDENT_ {  $$ = new parser::TIdent($1);  }
;
ListType : /* empty */ {  $$ = new parser::ListType();  }
  | Type {  $$ = new parser::ListType() ; $$->push_back($1);  }
  | Type _SYMB_4 ListType {  $3->push_back($1) ; $$ = $3 ;  }
;
Exp7 : _IDENT_ {  $$ = new parser::EVar($1);  }
  | _IDENT_ _SYMB_0 ListExp _SYMB_1 {  std::reverse($3->begin(),$3->end()) ;$$ = new parser::EApp($1, $3);  }
  | _INTEGER_ {  $$ = new parser::EInt($1);  }
  | _DOUBLE_ {  $$ = new parser::EDouble($1);  }
  | _SYMB_42 {  $$ = new parser::ELitTrue();  }
  | _SYMB_35 {  $$ = new parser::ELitFalse();  }
  | _STRING_ {  $$ = new parser::EString($1);  }
  | _SYMB_0 Exp _SYMB_1 {  $$ = $2;  }
  | Exp7 _SYMB_25 Exp _SYMB_26 {  $$ = new parser::EIndex($1, $3);  }
  | _SYMB_0 Type _SYMB_28 {  $$ = new parser::ENull($2);  }
;
Exp5 : _SYMB_9 Exp6 {  $$ = new parser::ENeg($2);  }
  | _SYMB_10 Exp6 {  $$ = new parser::ENot($2);  }
  | Exp6 {  $$ = $1;  }
;
Exp4 : Exp4 MulOp Exp5 {  $$ = new parser::EMul($1, $2, $3);  }
  | Exp5 {  $$ = $1;  }
;
Exp3 : Exp3 AddOp Exp4 {  $$ = new parser::EAdd($1, $2, $3);  }
  | Exp4 {  $$ = $1;  }
;
Exp2 : Exp2 RelOp Exp3 {  $$ = new parser::ERel($1, $2, $3);  }
  | Exp3 {  $$ = $1;  }
;
Exp1 : Exp2 _SYMB_11 Exp1 {  $$ = new parser::EAnd($1, $3);  }
  | Exp2 {  $$ = $1;  }
;
Exp : Exp1 _SYMB_12 Exp {  $$ = new parser::EOr($1, $3);  }
  | Exp1 {  $$ = $1;  }
;
Exp6 : Exp7 {  $$ = $1;  }
  | _SYMB_39 Type ListLength {  $$ = new parser::EAllocate($2, $3);  }
  | Exp6 _SYMB_27 Exp7 {  $$ = new parser::EDot($1, $3);  }
  | Exp6 _SYMB_29 Exp7 {  $$ = new parser::EDeref($1, $3);  }
;
ListExp : /* empty */ {  $$ = new parser::ListExp();  }
  | Exp {  $$ = new parser::ListExp() ; $$->push_back($1);  }
  | Exp _SYMB_4 ListExp {  $3->push_back($1) ; $$ = $3 ;  }
;
AddOp : _SYMB_13 {  $$ = new parser::OPlus();  }
  | _SYMB_9 {  $$ = new parser::OMinus();  }
;
MulOp : _SYMB_14 {  $$ = new parser::OTimes();  }
  | _SYMB_15 {  $$ = new parser::ODiv();  }
  | _SYMB_16 {  $$ = new parser::OMod();  }
;
RelOp : _SYMB_17 {  $$ = new parser::OLt();  }
  | _SYMB_18 {  $$ = new parser::OLe();  }
  | _SYMB_19 {  $$ = new parser::OGt();  }
  | _SYMB_20 {  $$ = new parser::OGe();  }
  | _SYMB_21 {  $$ = new parser::OEq();  }
  | _SYMB_22 {  $$ = new parser::ONe();  }
;
Length : _SYMB_25 Exp _SYMB_26 {  $$ = new parser::LLength($2);  }
;
ListLength : /* empty */ {  $$ = new parser::ListLength();  }
  | ListLength Length {  $1->push_back($2) ; $$ = $1 ;  }
;
Struct : _SYMB_41 _IDENT_ _SYMB_2 ListField _SYMB_3 {  $$ = new parser::SStruct($2, $4);  }
;
Field : Type _IDENT_ _SYMB_5 {  $$ = new parser::FField($1, $2);  }
;
ListField : /* empty */ {  $$ = new parser::ListField();  }
  | ListField Field {  $1->push_back($2) ; $$ = $1 ;  }
;
Member : Field {  $$ = new parser::MField($1);  }
  | Type _IDENT_ _SYMB_0 ListArg _SYMB_1 _SYMB_2 ListStm _SYMB_3 {  std::reverse($4->begin(),$4->end()) ;$$ = new parser::MFun($1, $2, $4, $7);  }
;
ListMember : /* empty */ {  $$ = new parser::ListMember();  }
  | ListMember Member {  $1->push_back($2) ; $$ = $1 ;  }
;

